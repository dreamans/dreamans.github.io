import{d as i,F as r,H as t,g as c}from"./q-71956c83.js";const l=[{text:"track() and useVisibleTask$()",id:"track-and-usevisibletask",level:2},{text:"Component Life Cycle and SSR",id:"component-life-cycle-and-ssr",level:2},{text:"When is useVisibleTask$() executed?",id:"when-is-usevisibletask-executed",level:2},{text:"Example",id:"example",level:3}],d={title:"useVisibleTask$()",meta:[],styles:[],links:[],frontmatter:{contributors:["manucorporat","adamdbradley","the-r3aper7","felixsanz","kerbelp","mhevery","cbazureau"]}},h={title:"useVisibleTask$()",contributors:["manucorporat","adamdbradley","the-r3aper7","felixsanz","kerbelp","mhevery","cbazureau"]};function s(n){const e=Object.assign({p:"p",code:"code",h2:"h2",a:"a",span:"span",blockquote:"blockquote",strong:"strong",ul:"ul",li:"li",h3:"h3"},n.components);return t(c,{children:[t(e.p,{children:["Use ",t(e.code,{children:"useVisibleTask$()"})," to execute code after the component is resumed. This is useful for setting up timers or streams on the client when the application is resumed."]}),`
`,t(e.h2,{id:"track-and-usevisibletask",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#track-and-usevisibletask",children:t(e.span,{class:"icon icon-link"})}),t(e.code,{children:"track()"})," and ",t(e.code,{children:"useVisibleTask$()"})]}),`
`,t(e.p,{children:[t(e.code,{children:"useVisibleTask$()"})," receives a ",t(e.code,{children:"track()"})," function just like ",t(e.code,{children:"useTask$()"}),". Use the ",t(e.code,{children:"track()"})," function to trigger the effect when the store is updated. See ",t(e.a,{href:"/tutorial/reactivity/explicit/",children:"reactivity"})," for more information."]}),`
`,t(e.h2,{id:"component-life-cycle-and-ssr",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#component-life-cycle-and-ssr",children:t(e.span,{class:"icon icon-link"})}),"Component Life Cycle and SSR"]}),`
`,t(e.p,{children:"Qwik is resumable. Resumability means that the application starts on the server and then is transferred to the client. On the client, the application continues execution from where it left off. A common use case is creating a component on the server, pausing, and then resuming on the client. To make the component fully functional, it may be necessary to execute code eagerly on the client to set up timers or streams."}),`
`,t(e.p,{children:[t(e.code,{children:"useVisibleTask$()"})," is a client-only method. (There is no equivalent on the server.)"]}),`
`,t(e.blockquote,{children:[`
`,t(e.p,{children:[t(e.strong,{children:"NOTE"})," See ",t(e.a,{href:"/docs/components/tasks/#usetask",children:t(e.code,{children:"useTask$()"})})," for behavior that needs to be executed on both client and server."]}),`
`]}),`
`,t(e.h2,{id:"when-is-usevisibletask-executed",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#when-is-usevisibletask-executed",children:t(e.span,{class:"icon icon-link"})}),"When is ",t(e.code,{children:"useVisibleTask$()"})," executed?"]}),`
`,t(e.p,{children:["Client effect code is executed after the component is resumed. The ",t(e.code,{children:"useVisibleTask$()"})," method takes an additional argument (",t(e.code,{children:"{strategy:'intersection-observer|document-ready|document-idle'}"}),") that controls when the effect is executed. There are three options:"]}),`
`,t(e.ul,{children:[`
`,t(e.li,{children:[t(e.code,{children:"intersection-observer"})," (default): the task will first execute when the element is visible in the viewport, under the hood it uses the IntersectionObserver API."]}),`
`,t(e.li,{children:[t(e.code,{children:"document-ready"}),": the task will first execute when the document is ready, under the hood it uses the document load event."]}),`
`,t(e.li,{children:[t(e.code,{children:"document-idle"}),": the task will first execute when the document is idle, under the hood it uses the requestIdleCallback API."]}),`
`]}),`
`,t(e.h3,{id:"example",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#example",children:t(e.span,{class:"icon icon-link"})}),"Example"]}),`
`,t(e.p,{children:["The example shows a clock component that is rendered below the fold. Use the ",t(e.code,{children:"useVisibleTask$()"})," to make the clock update the current time every second to make it work on the client. We have provided the utility function ",t(e.code,{children:"updateClock"})," to aid your implementation."]}),`
`,t(e.p,{children:["Keep in mind that ",t(e.code,{children:"useVisibleTask$()"})," should return a cleanup function that releases the ",t(e.code,{children:"setInterval"})," timer so that the timer can be properly cleaned up when the component is unmounted/destroyed."]})]})}function a(n={}){const{wrapper:e}=n.components||{};return e?t(e,Object.assign({},n,{children:t(s,n)})):s(n)}const u=()=>i(r,{children:i(a,{},3,null)},3,"lH6gnSEN");export{u as default,h as frontmatter,d as head,l as headings};
