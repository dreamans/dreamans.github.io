import{d as n,F as i,H as t,g as o}from"./q-71956c83.js";const c=[{text:"Speculative Module Fetching",id:"speculative-module-fetching",level:1},{text:"Pre-populating the Cache Per Page",id:"pre-populating-the-cache-per-page",level:3},{text:"Pre-populating the Per Interaction",id:"pre-populating-the-per-interaction",level:3},{text:"Pre-populate Cache Event",id:"pre-populate-cache-event",level:3},{text:"Pre-populating the Cache with a Service Worker",id:"pre-populating-the-cache-with-a-service-worker",level:2},{text:"Background Task",id:"background-task",level:3},{text:"Interactively Pre-populating the Cache",id:"interactively-pre-populating-the-cache",level:3},{text:"Caching Request and Response Pairs",id:"caching-request-and-response-pairs",level:2},{text:"Cache API",id:"cache-api",level:3},{text:"Dynamic Imports and Caching",id:"dynamic-imports-and-caching",level:3},{text:"Parallelizing Network Requests",id:"parallelizing-network-requests",level:2},{text:"Avoiding Duplicate Requests",id:"avoiding-duplicate-requests",level:3},{text:"Reducing Network Waterfalls",id:"reducing-network-waterfalls",level:3},{text:"User Service Worker Code",id:"user-service-worker-code",level:2},{text:"Disabled During Development and Preview",id:"disabled-during-development-and-preview",level:2},{text:"HTTP Cache vs. Service Worker Cache",id:"http-cache-vs-service-worker-cache",level:3},{text:"Misleading Empty Cache and Hard Reload",id:"misleading-empty-cache-and-hard-reload",level:3},{text:"Emptying the Service Worker Cache",id:"emptying-the-service-worker-cache",level:3}],h={title:"Qwik City Speculative Module Fetching",meta:[],styles:[],links:[],frontmatter:{contributors:["ulic75","mhevery","adamdbradley","hamatoyogi","manucorporat"]}},d={title:"Qwik City Speculative Module Fetching",contributors:["ulic75","mhevery","adamdbradley","hamatoyogi","manucorporat"]};function a(r){const e=Object.assign({h1:"h1",a:"a",span:"span",p:"p",em:"em",ul:"ul",li:"li",h3:"h3",h2:"h2",blockquote:"blockquote",ol:"ol",code:"code",div:"div",pre:"pre",strong:"strong"},r.components);return t(o,{children:[t(e.h1,{id:"speculative-module-fetching",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#speculative-module-fetching",children:t(e.span,{class:"icon icon-link"})}),"Speculative Module Fetching"]}),`
`,t(e.p,{children:["Qwik is able to load page and become interactive extremely fast due to its ability to startup ",t(e.em,{children:"without"})," JavaScript. In addition to this, Speculative Module Fetching is a powerful feature that allows Qwik to pre-populate the browser's cache in a background thread."]}),`
`,t(e.p,{children:["The goal of Qwik is not to pre-populate the cache with the entire application, but to have already cached what's possible ",t(e.em,{children:"at that time"}),". When the Qwik optimizer breaks apart the application, it's able to understand possible user interactions. And from this, it's just as important that it's able to understand what's not possible from user interaction, and to not bother loading those bundles."]}),`
`,t(e.ul,{children:[`
`,t(e.li,{children:t(e.a,{href:"#pre-populating-the-cache-with-a-service-worker",children:"Pre-populating the Cache with a Service Worker"})}),`
`,t(e.li,{children:t(e.a,{href:"#caching-request-and-response-pairs",children:"Caching Request and Response Pairs"})}),`
`,t(e.li,{children:t(e.a,{href:"#parallelizing-network-requests",children:"Parallelizing Network Requests"})}),`
`]}),`
`,t(e.h3,{id:"pre-populating-the-cache-per-page",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#pre-populating-the-cache-per-page",children:t(e.span,{class:"icon icon-link"})}),"Pre-populating the Cache Per Page"]}),`
`,t(e.p,{children:["Each page load will pre-populate the cache with bundles that ",t(e.em,{children:"could"})," be executed by the user, at that moment, on the page. For example, let's say that the page has a click listener on a button. When the page loads, the very first thing the service worker does is ensure the bundle for that click listener is already waiting in the ",t(e.a,{href:"#cache-api",children:"cache"}),". When the user clicks the button, and Qwik makes a request to the event listener's bundle, the goal is that the bundle is already sitting in the ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"browser's cache"})," ready to execute."]}),`
`,t(e.h3,{id:"pre-populating-the-per-interaction",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#pre-populating-the-per-interaction",children:t(e.span,{class:"icon icon-link"})}),"Pre-populating the Per Interaction"]}),`
`,t(e.p,{children:["You can think of the page load as the first user interaction, which pre-populates the cache with what the next user interaction ",t(e.em,{children:"could"})," be. When a follow-up interaction happens, such as opening a modal or menu, then Qwik will again emit another event with additional bundles that could be used since the last interaction happened. Pre-populating the cache not only happens on page load, but continuously as users interact with the application."]}),`
`,t(e.h3,{id:"pre-populate-cache-event",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#pre-populate-cache-event",children:t(e.span,{class:"icon icon-link"})}),"Pre-populate Cache Event"]}),`
`,t(e.p,{children:["The recommended strategy is to use a ",t(e.a,{href:"#pre-populating-the-cache-with-a-service-worker",children:"service worker"})," to populate the ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"browser's cache"}),". The Qwik framework itself should use the ",t(e.a,{href:"/docs/advanced/prefetching/#prefetching-implementation",children:"prefetchEvent"})," implementation, which is already the default."]}),`
`,t(e.h2,{id:"pre-populating-the-cache-with-a-service-worker",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#pre-populating-the-cache-with-a-service-worker",children:t(e.span,{class:"icon icon-link"})}),"Pre-populating the Cache with a Service Worker"]}),`
`,t(e.p,{children:["Traditionally, a service worker is used to cache most, or all, of the bundles that an application uses. ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers",children:"Service workers"})," are commonly seen only as a way to make an application work offline."]}),`
`,t(e.p,{children:["Qwik City, however, uses service workers quite differently to provide a powerful caching strategy. Instead, the goal is not to download the entire application, but rather to use the service worker to dynamically pre-populate the cache with what's ",t(e.em,{children:"possible"})," to execute. By ",t(e.em,{children:"not"})," downloading the entire application, resources are freed up, enabling the user to only request the necessary parts of the app they ",t(e.em,{children:"could"})," use to complete their current task on the screen."]}),`
`,t(e.p,{children:"Additionally, the service worker will automatically add listeners for these events emitted from Qwik."}),`
`,t(e.h3,{id:"background-task",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#background-task",children:t(e.span,{class:"icon icon-link"})}),"Background Task"]}),`
`,t(e.p,{children:["An advantage of using a service worker is that it's also an extension of a ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API",children:"worker"}),", which runs in a background thread."]}),`
`,t(e.blockquote,{children:[`
`,t(e.p,{children:"Web Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. The advantage of this is that laborious processing can be performed in a separate thread, allowing the main (usually the UI) thread to run without being blocked/slowed down."}),`
`]}),`
`,t(e.p,{children:"By pre-populating the cache from within a service worker (which is a worker), we're able to essentially run the code in a background task, in order to not interfere with the main UI thread. By not interfering with the main UI we're able to help improve the performance of the Qwik application for users."}),`
`,t(e.h3,{id:"interactively-pre-populating-the-cache",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#interactively-pre-populating-the-cache",children:t(e.span,{class:"icon icon-link"})}),"Interactively Pre-populating the Cache"]}),`
`,t(e.p,{children:["Qwik itself should be configured to use the ",t(e.a,{href:"/docs/advanced/prefetching/#prefetching-implementation",children:"prefetchEvent"})," implementation (which is also Qwik's default). When Qwik emits the event, the service worker registration actively forwards the event data to the installed and active service worker."]}),`
`,t(e.p,{children:["The service worker (which runs in a background thread) then fetches the modules and adds them to the browser's cache. “The main thread only needs to emit data about the required bundles, while the service worker’s sole focus is to cache those bundles. To achieve this, the service worker pre-populates the browser’s ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"Cache"}),"."]}),`
`,t(e.ol,{children:[`
`,t(e.li,{children:"If the browser already has it cached? Great, do nothing!"}),`
`,t(e.li,{children:"If the browser hasn't already cached this bundle, then let's kick off the fetch request."}),`
`]}),`
`,t(e.p,{children:["Read more about ",t(e.a,{href:"#caching-request-and-response-pairs",children:"Caching Request and Response Pairs"}),"."]}),`
`,t(e.p,{children:["Additionally, the service worker ensures that multiple requests for the same bundle do not happen at the same time. More about this in the ",t(e.a,{href:"#parallelizing-network-requests",children:"Parallelizing Network Requests"})," documentation."]}),`
`,t(e.h2,{id:"caching-request-and-response-pairs",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#caching-request-and-response-pairs",children:t(e.span,{class:"icon icon-link"})}),"Caching Request and Response Pairs"]}),`
`,t(e.p,{children:["In many traditional frameworks, the preferred strategy is to use ",t(e.code,{children:"<link>"})," with a ",t(e.code,{children:"rel"})," attribute of ",t(e.code,{children:"prefetch"}),", ",t(e.code,{children:"preload"})," or ",t(e.code,{children:"modulepreload"}),". However, there are ",t(e.a,{href:"/docs/advanced/prefetching/#link-rel",children:"enough known issues"})," that Qwik has preferred to not make ",t(e.code,{children:"link"})," the default prefetching strategy (though it still can be ",t(e.a,{href:"/docs/advanced/prefetching/",children:"configured"}),")."]}),`
`,t(e.p,{children:["Instead, Qwik prefers to use a newer approach that takes full advantage of the browser's ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"Cache API"}),", which is also better supported compared to ",t(e.a,{href:"/docs/advanced/prefetching/#link-rel",children:"modulepreload"}),"."]}),`
`,t(e.h3,{id:"cache-api",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#cache-api",children:t(e.span,{class:"icon icon-link"})}),"Cache API"]}),`
`,t(e.p,{children:["The ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"Cache API"}),", often associated with service workers, is a way to store request and response pairs in order for an application to work offline. In addition to enabling applications to work without connectivity, the same Cache API provides an extremely powerful caching mechanism available to Qwik."]}),`
`,t(e.p,{children:["Using the installed and activated ",t(e.a,{href:"#pre-populating-the-cache-with-a-service-worker",children:"service worker"})," to intercept requests, Qwik is able to handle specific requests for ",t(e.em,{children:"known"})," bundles. In contrast to the common way service workers are used, the default does not attempt to handle all requests, but rather, only known bundles generated by Qwik. The site's installed service worker can still be ",t(e.a,{href:"#user-service-worker-code",children:"customized by each site"}),"."]}),`
`,t(e.p,{children:["An advantage of Qwik's optimizer is it also generates a ",t(e.code,{children:"q-manifest.json"})," file. The manifest provides a detailed module graph of not only how bundles are associated, but also which symbols are within each bundle. This same module graph data is provided to the service worker which allows for every network request for known bundles to be handled by the cache."]}),`
`,t(e.h3,{id:"dynamic-imports-and-caching",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#dynamic-imports-and-caching",children:t(e.span,{class:"icon icon-link"})}),"Dynamic Imports and Caching"]}),`
`,t(e.p,{children:["When Qwik requests a module it uses a dynamic ",t(e.code,{children:"import()"}),". For example, let's say a user interaction happened, requiring Qwik to execute a dynamic import for ",t(e.code,{children:"/build/q-abc.js"}),". The code to do so would look something like this:"]}),`
`,t(e.div,{"data-rehype-pretty-code-fragment":"",children:t(e.pre,{"data-language":"ts","data-theme":"default",children:t(e.code,{"data-language":"ts","data-theme":"default",children:t(e.span,{class:"line",children:[t(e.span,{style:{color:"#569CD6"},children:"const"}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#4FC1FF"},children:"module"}),t(e.span,{style:{color:"#D4D4D4"},children:" = "}),t(e.span,{style:{color:"#C586C0"},children:"await"}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#569CD6"},children:"import"}),t(e.span,{style:{color:"#D4D4D4"},children:"("}),t(e.span,{style:{color:"#CE9178"},children:"'/build/q-abc.js'"}),t(e.span,{style:{color:"#D4D4D4"},children:");"})]})})})}),`
`,t(e.p,{children:[`What's important here is that Qwik itself has no knowledge of a prefetching or caching strategy. It's simply making a request for a URL. However, because we've installed a service worker, and the service worker is intercepting requests, it's able to inspect the URL and say, "look, this is a request for `,t(e.code,{children:"/build/q-abc.js"}),`! This is one of our bundles! Let's first check to see if we already have this in the cache before we do an actual network request."`]}),`
`,t(e.p,{children:"This is where the power of the service worker and Cache API comes in! Qwik first pre-populates the cache for modules the user may soon request within another thread. And better yet, if it's already cached, then there's no need for the browser to do anything."}),`
`,t(e.p,{children:["Other benefits include ",t(e.a,{href:"#parallelizing-network-requests",children:"Parallelizing Network Requests"}),"."]}),`
`,t(e.h2,{id:"parallelizing-network-requests",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#parallelizing-network-requests",children:t(e.span,{class:"icon icon-link"})}),"Parallelizing Network Requests"]}),`
`,t(e.p,{children:["In the ",t(e.a,{href:"#cache-api",children:"Caching Request and Response Pairs"})," docs we explained the powerful combination of the ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"Cache"})," and ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker",children:"Service Worker"})," APIs. However, we can take it even one step further by ensuring duplicate requests are not created for the same bundle, and we can prevent network waterfalls, all from within the background thread."]}),`
`,t(e.h3,{id:"avoiding-duplicate-requests",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#avoiding-duplicate-requests",children:t(e.span,{class:"icon icon-link"})}),"Avoiding Duplicate Requests"]}),`
`,t(e.p,{children:["As an example, let's say an end-user currently has a slow 3G connection. When they first request the landing page, as fast as this slow network allows, the device downloads the HTML and renders the content (an area where Qwik really shines). On this slow connection, it'd be a shame if they'd have to also download a few more hundred kilobytes just to ",t(e.a,{href:"https://www.builder.io/blog/hydration-is-pure-overhead",children:"make their app work and become interactive"}),"."]}),`
`,t(e.p,{children:`However, because the app was built with Qwik, the end-user doesn't need to download the entire application for it to become interactive. Instead, the end-user already downloaded the SSR rendered HTML app, and any interactive parts, such as an "Add to cart" button, can be prefetched immediately.`}),`
`,t(e.blockquote,{children:[`
`,t(e.p,{children:["Note that we're only prefetching the actual listener code, and ",t(e.em,{children:"not"})," the entire stack of the component tree render functions."]}),`
`]}),`
`,t(e.p,{children:["In this extremely common real-world example of a device with a slow connection, the device immediately starts to pre-populate the cache for the possible interactions that are visible by the end-user. However, due to their slow connection, even though we started to cache the modules as soon as possible in a ",t(e.a,{href:"#background-task",children:"background thread"}),", the fetch request itself could still be in flight."]}),`
`,t(e.p,{children:"For demo purposes, let's say the fetching for this bundle takes two seconds. However, after one second of viewing the page, the user clicks on the button. In a traditional framework, there's a good chance that absolutely nothing would happen! If the framework hasn't finished downloading, hydrating and re-rendering, the event listener can't be added to the button yet. Which in turn means that the user's interaction would just be lost."}),`
`,t(e.p,{children:"However, with Qwik's caching, if the user clicked the button, and we already started a request one second ago, and it has one second left until it's fully received, then the end-user only has to wait for one second. Remember, they're on a slow 3G connection in this demo. Luckily the user already received the full rendered landing page, so they're already looking at a completed page. Next, they're only pre-populating the cache with the bits of the app they could interact with, and their slow connection is dedicated to just those bundle(s). This is in contrast to their slow connection downloading all of the app, just to execute one listener."}),`
`,t(e.p,{children:["Qwik is able to intercept requests for known bundles, and if a fetch in a background thread is already in flight, and then a user requests the same bundle, it'll ensure that the second request is able to re-use the initial one, which may already be done downloading. Trying to perform any of this with the ",t(e.a,{href:"/docs/advanced/prefetching/#link-rel",children:"link"})," also shows why Qwik preferred to not make it the default, but instead uses the caching API and intercepts requests with a service worker."]}),`
`,t(e.h3,{id:"reducing-network-waterfalls",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#reducing-network-waterfalls",children:t(e.span,{class:"icon icon-link"})}),"Reducing Network Waterfalls"]}),`
`,t(e.p,{children:"A network waterfall is when numerous requests happen one after another, like steps downstairs, rather than in parallel. A waterfall of network requests will usually hurt performance because it increases the time until all modules are downloaded, rather than each module starting to download at the same time."}),`
`,t(e.p,{children:"Below is an example with three modules: A, B and C. Module A imports B, and B imports C. The HTML document is what starts the waterfall by first requesting Module A."}),`
`,t(e.div,{"data-rehype-pretty-code-fragment":"",children:t(e.pre,{"data-language":"ts","data-theme":"default",children:t(e.code,{"data-language":"ts","data-theme":"default",children:[t(e.span,{class:"line",children:[t(e.span,{style:{color:"#C586C0"},children:"import"}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#CE9178"},children:"'./b.js'"}),t(e.span,{style:{color:"#D4D4D4"},children:";"})]}),`
`,t(e.span,{class:"line",children:[t(e.span,{style:{color:"#9CDCFE"},children:"console"}),t(e.span,{style:{color:"#D4D4D4"},children:"."}),t(e.span,{style:{color:"#DCDCAA"},children:"log"}),t(e.span,{style:{color:"#D4D4D4"},children:"("}),t(e.span,{style:{color:"#CE9178"},children:"'Module A'"}),t(e.span,{style:{color:"#D4D4D4"},children:");"})]})]})})}),`
`,t(e.div,{"data-rehype-pretty-code-fragment":"",children:t(e.pre,{"data-language":"ts","data-theme":"default",children:t(e.code,{"data-language":"ts","data-theme":"default",children:[t(e.span,{class:"line",children:[t(e.span,{style:{color:"#C586C0"},children:"import"}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#CE9178"},children:"'./c.js'"}),t(e.span,{style:{color:"#D4D4D4"},children:";"})]}),`
`,t(e.span,{class:"line",children:[t(e.span,{style:{color:"#9CDCFE"},children:"console"}),t(e.span,{style:{color:"#D4D4D4"},children:"."}),t(e.span,{style:{color:"#DCDCAA"},children:"log"}),t(e.span,{style:{color:"#D4D4D4"},children:"("}),t(e.span,{style:{color:"#CE9178"},children:"'Module B'"}),t(e.span,{style:{color:"#D4D4D4"},children:");"})]})]})})}),`
`,t(e.div,{"data-rehype-pretty-code-fragment":"",children:t(e.pre,{"data-language":"ts","data-theme":"default",children:t(e.code,{"data-language":"ts","data-theme":"default",children:t(e.span,{class:"line",children:[t(e.span,{style:{color:"#9CDCFE"},children:"console"}),t(e.span,{style:{color:"#D4D4D4"},children:"."}),t(e.span,{style:{color:"#DCDCAA"},children:"log"}),t(e.span,{style:{color:"#D4D4D4"},children:"("}),t(e.span,{style:{color:"#CE9178"},children:"'Module C'"}),t(e.span,{style:{color:"#D4D4D4"},children:");"})]})})})}),`
`,t(e.div,{"data-rehype-pretty-code-fragment":"",children:t(e.pre,{"data-language":"html","data-theme":"default",children:t(e.code,{"data-language":"html","data-theme":"default",children:t(e.span,{class:"line",children:[t(e.span,{style:{color:"#808080"},children:"<"}),t(e.span,{style:{color:"#569CD6"},children:"script"}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#9CDCFE"},children:"type"}),t(e.span,{style:{color:"#D4D4D4"},children:"="}),t(e.span,{style:{color:"#CE9178"},children:'"module"'}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#9CDCFE"},children:"src"}),t(e.span,{style:{color:"#D4D4D4"},children:"="}),t(e.span,{style:{color:"#CE9178"},children:'"./a.js"'}),t(e.span,{style:{color:"#808080"},children:"></"}),t(e.span,{style:{color:"#569CD6"},children:"script"}),t(e.span,{style:{color:"#808080"},children:">"})]})})})}),`
`,t(e.p,{children:["In this example, when Module ",t(e.code,{children:"A"})," is first requested, the browser has no idea that it should also start requesting Module ",t(e.code,{children:"B"})," and ",t(e.code,{children:"C"}),". It doesn't even know it needs to start requesting Module ",t(e.code,{children:"B"}),", until AFTER Module ",t(e.code,{children:"A"})," has finished downloading. It's a common problem in that the browser doesn't know ahead of time what it should start to request, until after each module has finished downloading."]}),`
`,t(e.p,{children:["However, because our service worker contains a module graph generated from the manifest, we do know all of the modules which ",t(e.em,{children:"will"})," be requested next. So when either user interaction or a prefetch for a bundle happens, the browser initiates the request for all of the bundles that ",t(e.em,{children:"will"})," be requested. This allows us to drastically reduce the time it takes to request all bundles."]}),`
`,t(e.h2,{id:"user-service-worker-code",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#user-service-worker-code",children:t(e.span,{class:"icon icon-link"})}),"User Service Worker Code"]}),`
`,t(e.p,{children:["The default service worker that is installed by Qwik City can still be controlled entirely by the application. For example, the source file ",t(e.code,{children:"src/routes/service-worker.ts"})," becomes ",t(e.code,{children:"/service-worker.js"}),", which is the script requested by the browser. Notice how its place within ",t(e.code,{children:"src/routes"})," still follows the same directory-based routing pattern."]}),`
`,t(e.p,{children:["Below is an example of a default ",t(e.code,{children:"src/routes/service-worker.ts"})," source file:"]}),`
`,t(e.div,{"data-rehype-pretty-code-fragment":"",children:t(e.pre,{"data-language":"ts","data-theme":"default",children:t(e.code,{"data-language":"ts","data-theme":"default",children:[t(e.span,{class:"line",children:[t(e.span,{style:{color:"#C586C0"},children:"import"}),t(e.span,{style:{color:"#D4D4D4"},children:" { "}),t(e.span,{style:{color:"#9CDCFE"},children:"setupServiceWorker"}),t(e.span,{style:{color:"#D4D4D4"},children:" } "}),t(e.span,{style:{color:"#C586C0"},children:"from"}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#CE9178"},children:"'@builder.io/qwik-city/service-worker'"}),t(e.span,{style:{color:"#D4D4D4"},children:";"})]}),`
`,t(e.span,{class:"line",children:" "}),`
`,t(e.span,{class:"line",children:[t(e.span,{style:{color:"#DCDCAA"},children:"setupServiceWorker"}),t(e.span,{style:{color:"#D4D4D4"},children:"();"})]}),`
`,t(e.span,{class:"line",children:" "}),`
`,t(e.span,{class:"line",children:[t(e.span,{style:{color:"#DCDCAA"},children:"addEventListener"}),t(e.span,{style:{color:"#D4D4D4"},children:"("}),t(e.span,{style:{color:"#CE9178"},children:"'install'"}),t(e.span,{style:{color:"#D4D4D4"},children:", () "}),t(e.span,{style:{color:"#569CD6"},children:"=>"}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#9CDCFE"},children:"self"}),t(e.span,{style:{color:"#D4D4D4"},children:"."}),t(e.span,{style:{color:"#DCDCAA"},children:"skipWaiting"}),t(e.span,{style:{color:"#D4D4D4"},children:"());"})]}),`
`,t(e.span,{class:"line",children:" "}),`
`,t(e.span,{class:"line",children:[t(e.span,{style:{color:"#DCDCAA"},children:"addEventListener"}),t(e.span,{style:{color:"#D4D4D4"},children:"("}),t(e.span,{style:{color:"#CE9178"},children:"'activate'"}),t(e.span,{style:{color:"#D4D4D4"},children:", () "}),t(e.span,{style:{color:"#569CD6"},children:"=>"}),t(e.span,{style:{color:"#D4D4D4"},children:" "}),t(e.span,{style:{color:"#9CDCFE"},children:"self"}),t(e.span,{style:{color:"#D4D4D4"},children:"."}),t(e.span,{style:{color:"#9CDCFE"},children:"clients"}),t(e.span,{style:{color:"#D4D4D4"},children:"."}),t(e.span,{style:{color:"#DCDCAA"},children:"claim"}),t(e.span,{style:{color:"#D4D4D4"},children:"());"})]})]})})}),`
`,t(e.p,{children:["The source code for ",t(e.code,{children:"src/routes/service-worker.ts"})," can be modified by the developer however they'd like. This includes opting-in, or opting-out, of setting up Qwik City's service worker."]}),`
`,t(e.p,{children:["Notice that the ",t(e.code,{children:"setupServiceWorker()"})," function is imported from ",t(e.code,{children:"@builder.io/qwik-city/service-worker"})," and executed at the top of the source file. If, and where, this function is called can be modified by the developer. For example, the developer may want to handle the fetch requests first, in which case they'd add their own fetch listener above ",t(e.code,{children:"setupServiceWorker()"}),". Or if they didn't want to use Qwik City's service worker at all, they would just have to remove ",t(e.code,{children:"setupServiceWorker()"})," from the file."]}),`
`,t(e.p,{children:["Additionally, the default ",t(e.code,{children:"src/routes/service-worker.ts"})," file comes with an ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event",children:"install"})," and ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event",children:"activate"})," event listeners, each added at the bottom of the file. The callbacks provided are the recommended callbacks. However, the developer can modify these callbacks depending on their own app's requirements."]}),`
`,t(e.p,{children:["Another important note is that Qwik City's request intercepting is ",t(e.em,{children:"only"})," for Qwik bundles, it does not attempt to handle any requests which are not a part of its build."]}),`
`,t(e.p,{children:"So while Qwik City does provide a way to help prefetch and cache bundles, it does not take full control of the app's service worker. This still allows developers to add their service worker logic without conflicting with Qwik."}),`
`,t(e.h2,{id:"disabled-during-development-and-preview",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#disabled-during-development-and-preview",children:t(e.span,{class:"icon icon-link"})}),"Disabled During Development and Preview"]}),`
`,t(e.p,{children:"One gotcha during development and using Vite's preview mode is that the service worker is disabled which also disables speculative module fetching. During development we want to always ensure the latest development code is being used, rather than previous code."}),`
`,t(e.p,{children:"Speculative module fetching only kicks on a production build. To see speculative module fetching in action you'll need to run the production build on a server other than development or preview."}),`
`,t(e.h3,{id:"http-cache-vs-service-worker-cache",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#http-cache-vs-service-worker-cache",children:t(e.span,{class:"icon icon-link"})}),"HTTP Cache vs. Service Worker Cache"]}),`
`,t(e.p,{children:["Speculative module fetching may appear to not be working partly due to the various levels of caching. For example, the browser itself may cache requests in its ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching",children:"HTTP cache"}),", and the service worker may cache requests in the ",t(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",children:"Cache API"}),". Just emptying one of the caches may not be enough to see the effects of speculative module fetching."]}),`
`,t(e.h3,{id:"misleading-empty-cache-and-hard-reload",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#misleading-empty-cache-and-hard-reload",children:t(e.span,{class:"icon icon-link"})}),"Misleading Empty Cache and Hard Reload"]}),`
`,t(e.p,{children:["When developers run ",t(e.a,{href:"https://developer.chrome.com/blog/hard-reload/",children:"Empty Cache and Hard Reload"}),", it's a bit misleading because it actually ",t(e.em,{children:"only"})," empties the browser's HTTP cache. It's not, however, emptying the service worker's cache. Even though the browser's HTTP cache is empty, the service worker still has the previous cached requests."]}),`
`,t(e.p,{children:['Additionally, when "Empty Cache and Hard Reload" is used, the browser sends a ',t(e.code,{children:"no-cache"})," cache-control header in the ",t(e.em,{children:"request"})," to the server. Because the request has a ",t(e.code,{children:"no-cache"})," cache-control header, the service worker purposely does not use its own cache, and instead the browser performs the usual HTTP fetch again."]}),`
`,t(e.h3,{id:"emptying-the-service-worker-cache",children:[t(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#emptying-the-service-worker-cache",children:t(e.span,{class:"icon icon-link"})}),"Emptying the Service Worker Cache"]}),`
`,t(e.p,{children:"The recommended way to test specualtive module fetching is to:"}),`
`,t(e.ul,{children:[`
`,t(e.li,{children:[t(e.strong,{children:"Unregister the service worker"}),`: In Chrome DevTools, go to the Application tab, and under Service Workers, click the "Unregister" link for the for your site's service worker.`]}),`
`,t(e.li,{children:[t(e.strong,{children:'Delete the "QwikBuild" Cache Storage'}),': In Chrome DevTools, go to the Application tab, and under Cache Storage on the left side, right click "Delete" on the "QwikBuild" cache storage.']}),`
`,t(e.li,{children:[t(e.strong,{children:"Do not hard reload"}),": Instead of hard reloading, which would send a no-cache cache-control to the service worker, just click the URL bar and hit enter. This will send a normal request as if you were a first time visitor."]}),`
`]}),`
`,t(e.p,{children:"Note that this process is only for testing the speculative module fetching, and is not required for new builds. Each build will create a new service worker, and the old service worker will be automatically unregistered."})]})}function l(r={}){const{wrapper:e}=r.components||{};return e?t(e,Object.assign({},r,{children:t(a,r)})):a(r)}const p=()=>n(i,{children:n(l,{},3,null)},3,"PD3BWmxl");export{p as default,d as frontmatter,h as head,c as headings};
